整体思路如下：
以块为单位，逐块加载，且只加载里角色最近的块。
每个块中定义如下3个矩形：
1、box块本身范围，
2、box_add当角色移动到此矩形外就加载此块在这个方向上相邻的块，如果这个相邻块已经加载就不需要再次加载，
3、box_remove当角色移动到此范围外，就销毁（或者回收）此块。
一开始只创建一个块，当角色移动到指定box_add外时，就去检查这个方向的相邻块是否已经加载，如果未加载，就需要执行加载逻辑。当角色继续移动到超出box_remove外时，就可以销毁此块（也可以回收此块）。当角色移动当矩形的4个角时，应该同时检查周围3个块。根据此设计，内存中最多同时存在4个这样的块。
  

如图所示，3个矩形大致如此，注意，box_add和box_remove的大小关系，应该给添加到移除留一段缓冲距离。

然后是每个块的具体实现，这里参考了下面这篇文章，但是我并没有用四叉树。
http://www.manew.com/thread-101305-1-1.html
我的方法是这样的，将这个块分成n片，每片有m段网格段，但是会根据片与角色的距离做LOD，m是网格最细分的情况下。因为Lod的关系，m必须是2的整数次冥，于是32是我认为一个比较合理的值，因为分32段的话，一个片就有32*32*2=2048个三角面。m的大小确定了，那就是开始确定n了，n可以不是2的整数次冥。因为我在计算顶点、UV、法线的时候是直接将整个块的所有顶点都先计算出来缓存着的，而且内存中最大可能4块同时存在。一个顶点是12+8+12=32字节（顶点向量+UV向量+法线向量），最大内存情况应该是（n*m）*(n*m)*32*4。当m=32时，换算成MB就是n*n/8(MB),当N为8时是8M，我认为是比较好的，你也可以自行调节。这2个值确定了后，顺便把块大小box也确定了，由于计算UV的时候每个块的起点UV都是（0，0），所以应该给材质的Tiling设置成整数倍，然后按1米=100像素的比例去设置box大小（不一定要严格按照这个比例，自己觉得细节够就可以）。我设置Tiling为10，因此把BOX大小设置成102.4，box_add建议是box的一半，box_remove建议是box的2倍。上面把参数确定后，就可以开始生产片了，生成片的过程大致如下：
1.生成高度图，
2.根据高度图生成一张遮罩图，用于控制显示哪张贴图中的像素，
3.预计算此块最细分情况下所有顶点的位置、UV、法线，
4.生成LOD最大（就是网格数最少）时的所有片。
其中高度图生成用到随机分形算法，参考地址：
http://www.cnblogs.com/lookof/archive/2009/03/18/1415259.html
mask的生成分2部分，一个是根据高度图生成mask的color数组，这部分找不到参考地址了。。。。。。
另一个是怎么利用这个数组，参考地址：
http://liweizhaolili.blog.163.com/blog/static/1623074420136292730744/

接下来是更新过程，
首先，根据最开始的思路检查块的增删，
然后，计算块中所有片的LOD，根据LOD改变片的网格。
lod部分参考，我上面已经给出过地址了。
